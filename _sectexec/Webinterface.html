---
title: Webinterface
layout: "page"
icon: fa-comment
order: 5
---


<!DOCTYPE html>
<html lang="{{ site.lang | default: "en-US" }}">
	<head>
		<style>
			select {
				margin: 25px;
				width: 120px;
				padding: 5px 5px 5px 5px;
				font-size: 16px;
				border: 1px solid #CCC;
				height: 40px;
            }
            
            button {
            	margin: 5px;
				width: 80px;
				font-size: 16px;
				border: 1px solid #CCC;
				height: 30px;
          	}	
		</style>
	</head>
  
	<body>
		<script>
        	async function check_food_part(food, part) {
            	// Construct your SPARQL query
                const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    PREFIX foodon: <http://purl.obolibrary.org/obo/>
                    ASK {
                      foodon:${food} rdfs:subClassOf* ?dis.
                      ?dis owl:onProperty 	cut:hasPart.
                      ?dis owl:someValuesFrom ?tar.
                      ?tar owl:intersectionOf ?tar_int.
                      ?tar_int rdf:first cut:${part}.
		      ?tar_int rdf:rest ?rest.
		      ?rest rdf:first ?first.
		      ?first owl:onProperty cut:hasEdibility.
		      {?first owl:someValuesFrom cut:MustBeAvoided.}
		      UNION
		      {?first owl:someValuesFrom cut:ShouldBeAvoided.}
                    }
                `;
                
            	// Triply SPARQL endpoint URL
                const endpointUrl = 'https://api.krr.triply.cc/datasets/mkumpel/FruitCuttingKG/services/FoodCuttingKG/sparql'

                const requestOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/sparql-query',
                    },
                    body: sparqlQuery,
                }

                try {
                    const response = await fetch(endpointUrl, requestOptions)
                    const data = await response.json()
                    return data.boolean
                } catch (error) {
                    console.error('Error:', error)
                    return false
                }
            }
            
            async function get_prior_task(verb) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    SELECT ?res WHERE {
                        ${verb} rdfs:subClassOf* ?sub.
                        ?sub owl:onProperty cut:requiresPriorTask .
                        ?sub owl:someValuesFrom ?priortask.
                        BIND(REPLACE(STR(?priortask), "^.*[#/]", "") AS ?res).
                    }
                `;
                
            	return query_text(sparqlQuery, '')
            }
            
            async function query_text(query, alternative) {
            	// Triply SPARQL endpoint URL
                const endpointUrl = 'https://api.krr.triply.cc/datasets/mkumpel/FruitCuttingKG/services/FoodCuttingKG/sparql'

                const requestOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/sparql-query',
                    },
                    body: query,
                }

                try {
                    const response = await fetch(endpointUrl, requestOptions)
                    const data = await response.json()
                    const firstObject = data[0];
                    return firstObject.res
                } catch (error) {
                    console.error('Error:', error)
                    return alternative
                }
            }
            
            async function get_peel_tool(food) {
                const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    PREFIX foodon: <http://purl.obolibrary.org/obo/>
                    SELECT ?res WHERE {
                        foodon:${food} rdfs:subClassOf* ?peel_dis.
                        ?peel_dis owl:onProperty soma:hasDisposition.
                        ?peel_dis owl:someValuesFrom ?peel_dis_vals.
                        ?peel_dis_vals owl:intersectionOf ?afford_vals.
                        ?afford_vals rdf:first cut:Peelability.
                        ?afford_vals rdf:rest ?task_trigger.
                        ?task_trigger rdf:rest ?trigger.
                        ?trigger rdf:first ?trigger_wo_nil.
                        ?trigger_wo_nil owl:onProperty soma:affordsTrigger.
                        ?trigger_wo_nil owl:allValuesFrom ?trigger_tool.
                        ?trigger_tool owl:allValuesFrom ?tool.
                        BIND(REPLACE(STR(?tool), "^.*[#/]", "") AS ?res).
                    }
                `;
                
            	return query_text(sparqlQuery, 'Peeler')
            }
            
            async function get_cut_tool(food) {
                const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    PREFIX foodon: <http://purl.obolibrary.org/obo/>
                    PREFIX sit_aware: <http://www.ease-crc.org/ont/situation_awareness#>
                    SELECT ?res WHERE {
                        foodon:${food} rdfs:subClassOf* ?peel_dis.
                        ?peel_dis owl:onProperty soma:hasDisposition.
                        ?peel_dis owl:someValuesFrom ?peel_dis_vals.
                        ?peel_dis_vals owl:intersectionOf ?afford_vals.
                        ?afford_vals rdf:first sit_aware:Cuttability.
                        ?afford_vals rdf:rest ?task_trigger.
                        ?task_trigger rdf:rest ?trigger.
                        ?trigger rdf:first ?trigger_wo_nil.
                        ?trigger_wo_nil owl:onProperty soma:affordsTrigger.
                        ?trigger_wo_nil owl:allValuesFrom ?trigger_tool.
                        ?trigger_tool owl:allValuesFrom ?tool.
                        BIND(REPLACE(STR(?tool), "^.*[#/]", "") AS ?res).
                    }
                `;
                
            	return query_text(sparqlQuery, 'Knife')
            }
            
            async function get_target(verb) {
                const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    SELECT ?res WHERE {
                      {
                        ${verb} rdfs:subClassOf* ?inter_node.
                        ?inter_node owl:intersectionOf ?in_res_node.
                        ?in_res_node rdf:first ?input_node.
                        ?input_node owl:onProperty cut:hasInputObject.
                        ?input_node owl:someValuesFrom ?target.
                        FILTER NOT EXISTS {
                            ?target owl:unionOf ?union_node.
                        }
                        BIND(REPLACE(STR(?target), "^.*[#/]", "") AS ?res).
                      } 
                      UNION
                      {
                        ${verb} rdfs:subClassOf* ?inter_node.
                        ?inter_node owl:intersectionOf ?in_res_node.
                        ?in_res_node rdf:first ?input_node.
                        ?input_node owl:onProperty cut:hasInputObject.
                        ?input_node owl:someValuesFrom ?targets_node.
                        ?targets_node owl:unionOf ?union_node.
                        ?union_node rdf:first ?target.
                        BIND(REPLACE(STR(?target), "^.*[#/]", "") AS ?res).
                      }
                    } 
                `;
                
            	return query_text(sparqlQuery, 'Food')
            }
            
            async function get_repetitions(verb) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

                    SELECT ?res WHERE {
                      {
                        ${verb} rdfs:subClassOf* ?rep_node.
                        ?rep_node owl:onProperty cut:repetitions.
                        FILTER EXISTS {
                            ?rep_node owl:hasValue ?val.
                        }
                        BIND("exactly 1" AS ?res)
                      }
                      UNION
                      {
                        ${verb} rdfs:subClassOf* ?rep_node.
                        ?rep_node owl:onProperty cut:repetitions.
                        FILTER EXISTS {
                            ?rep_node owl:minQualifiedCardinality ?val.
                        }
                        BIND("at least 1" AS ?res)
                      }
                    }
                `;
                
            	return query_text(sparqlQuery, '1')
            }
            
            async function get_cutting_position(verb) {
            	const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX cut: <http://www.ease-crc.org/ont/food_cutting#>
                    PREFIX soma: <http://www.ease-crc.org/ont/SOMA.owl#>
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    SELECT * WHERE {
                        ${verb} rdfs:subClassOf* ?pos_node.
                        ?pos_node owl:onProperty cut:affordsPosition.
                        ?pos_node owl:someValuesFrom ?pos.
                        BIND(REPLACE(STR(?pos), "^.*[#/]", "") AS ?res).
                    } 
                `;
                
            	return query_text(sparqlQuery, 'middle')
            }
            
            function add_to_table(number, motion, inference) {
            	var motion_table = document.getElementById("motions");
            	var row = motion_table.insertRow(-1);
                var numb = row.insertCell(0);
                var mot = row.insertCell(1);
                var inf = row.insertCell(2);
              	numb.innerHTML = number + ".";
                mot.innerHTML = motion;
                inf.innerHTML = inference;
            }
            
            function clear_table() {
            	var motion_table = document.getElementById("motions");
            	var rowCount = motion_table.rows.length;
                for (var i = rowCount - 1; i >= 1; i--) {
                    motion_table.deleteRow(i);
                }
            }
        
			async function query_and_show() {
				var container = document.getElementById("results");
				var header = document.getElementById("header");
                
				var verbs = document.getElementById("verb-select");
				var foods = document.getElementById("food-select");
                var selected_verb = verbs.options[verbs.selectedIndex].textContent
                var selected_food = foods.options[foods.selectedIndex].textContent

				// changing the container visibility
				container.style.display = "block";

				// changing the header
				header.textContent = "Motions for " + selected_verb + " a / an " + selected_food + ":"
                
                // query the ontology
                var remove_peel = await check_food_part(foods.value, 'Peel')
                var remove_shell = await check_food_part(foods.value, 'Shell')
                var remove_stem = await check_food_part(foods.value, 'Stem')
                var remove_core = await check_food_part(foods.value, 'Core')
                var prior_task = await get_prior_task(verbs.value)
                var peel_tool = await get_peel_tool(foods.value)
                var cut_tool = await get_cut_tool(foods.value)
                var reps = await get_repetitions(verbs.value)
                var pos = await get_cutting_position(verbs.value)
                var shape = await get_target(verbs.value)
                
                // create motion list from ontology query
                clear_table()
                curr_step = 1
                target = ''
                
                // optional preconditions
                if (remove_peel || remove_shell) {
                	add_to_table(curr_step++, "Peeling using a peeling tool", "has peel = true<br>peeling tool = " + peel_tool)
                }
                if (remove_stem) {
                	add_to_table(curr_step++, "Removing the stem", "has stem = true")
                }
                if (remove_core) {
                	add_to_table(curr_step++, "Removing the core", "has core = true")
                }
                if (prior_task != '') {
                	add_to_table(curr_step++, "Execute a prior task: " + prior_task, "has prior task = true<br>prior task = " + prior_task)
                }
                
                // picking up the tool
                add_to_table(curr_step, "Picking up the cutting tool by ...", "cutting tool = " + cut_tool)
                add_to_table(curr_step + "a", " ... approaching the cutting tool", "cutting tool = " + cut_tool)
                add_to_table(curr_step + "b", "... grasping the cutting tool", "cutting tool = " + cut_tool)
                add_to_table(curr_step++ + "c", "... lifting the cutting tool", "cutting tool = " + cut_tool)
                
                // deciding on the target
                if(shape == 'Food') {
                	target = selected_food
                } else {
                	target = selected_food + " " + shape
                }
                
                // cutting the food object the necessary amount of times
                add_to_table(curr_step, "Cutting the target object at the position n time(s) by ...", "target object = " + target + "<br>position = " + pos + "<br>n = " + reps)
              	add_to_table(curr_step + "a", "... approaching the target object at the position", "target object = " + target + "<br>position = " + pos)
              	add_to_table(curr_step + "b", "... lowering the cutting tool through the target object", "cutting tool = " + cut_tool + "<br>target object = " + target)
              	add_to_table(curr_step++ + "c", "... lifting the cutting tool", "cutting tool = " + cut_tool)

				// putting down the tool
                add_to_table(curr_step, "Placing the cutting tool down by ...", "cutting tool = " + cut_tool)
                add_to_table(curr_step + "a", "... approaching the target location", "")
                add_to_table(curr_step + "b", "... releasing the cutting tool", "cutting tool = " + cut_tool)
                add_to_table(curr_step + "c", "... lifting the empty gripper", "")
			}
		</script>
		<center><h1>Challenge: We want to enable robots to learn everyday manipulation tasks from the Web and thus make abstract knowledge <b>actionable</b>.</h1></center>

		This challenge is important for robots that can perform a wide breadth of manipulation tasks and task variations, that can be performed by various robots using various tools for a variety of purposes.<br>

		<p>For a robot to successfully perform such a breadth of maniulation actions, it needs to <b>understand</b> given tasks. On this website we show how robots can use a knowledge graph to understand a given task by answering questions such as<br>
			"What is the result state when performing a specific action?"<br>
			"What object can be used to perform a given task?" "Is there a preferred object to use for this task?"<br>
			"Can the task be performed on a given object?" etc.</p>
			
		<p>We start tackling this challenge by focusing on selected task domains, starting with cutting. The idea is that our methodology can teach robots to cut any fruit with any to for any purpose, as visualised below. For this, the robot needs to query the knowledge graph to parameterise its general action plan.</p>
		<p align="center">
  <img src="img/Motivation3.jpg" width="600" alt="Enabling cognitive robots to cut food objects through an ontology"/><br>
</p>	
		<p><b>Usage:</b> Please choose a <b>cutting verb</b> and a <b>food object</b> from the dropdown lists below. Based on a food cutting knowledge graph, a sequence of motions will be returned that a robot can use for action parameterisation.</p>
  
		<label for="food-select">I want the robot to execute the <b>task</b>: </label>
		<select name="verbs" id="verb-select">		
			<option value="cut:Carving">Carving</option>
			<option value="cut:Chopping">Chopping</option>
			<option value="cut:Cubing">Cubing</option>
			<option value="soma:Cutting">Cutting</option>
			<option value="soma:Dicing">Dicing</option>			
			<option value="cut:Halving">Halving</option>			
			<option value="cut:Julienning">Julienning</option>
			<option value="cut:Mincing">Mincing</option>			
			<option value="cut:Paring">Paring</option>			
			<option value="cut:Quartering">Quartering</option>
			<option value="cut:Sawing">Sawing</option>			
			<option value="soma:Slicing">Slicing</option>
			<option value="cut:Slivering">Slivering</option>
			<option value="cut:Snipping">Snipping</option>
		</select>
		
		<label for="food-select"> on <b>a / an</b> </label>
		<select name="foods" id="food-select">
			<option value="FOODON_00003523">Almond</option>
			<option value="FOODON_03301710">Apple</option>
			<option value="FOODON_00004183">Banana</option>
			<option value="FOODON_03301403">Bean</option>
			<option value="bread">Bread</option>			
			<option value="FOODON_03301240">Cherry</option>	
			<option value="FOODON_03306596">Citron</option>
			<option value="FOODON_00003449">Coconut</option>				
			<option value="FOODON_00003415">Cucumber</option>				
			<option value="FOODON_03306597">Kumquat</option>
			<option value="FOODON_03301441">Lemon</option>
			<option value="FOODON_00003661">Lime</option>				
			<option value="FOODON_03317509">Olive</option>
			<option value="FOODON_03309832">Orange</option>
			<option value="FOODON_00003520">Pepper</option>
			<option value="FOODON_00003459">Pineapple</option>
			<option value="FOODON_00003486">Pumpkin</option>
			<option value="FOODON_00003539">Squash</option>				
			<option value="FOODON_00003443">Strawberry</option>
			<option value="FOODON_03309927">Tomato</option>
		</select>
		
		<button type="button" onclick="query_and_show()">Query</button> 
		
		<div id="results" style='display: none'>
			<p id="header"></p>
			<table id="motions">
            <tr>
              <th>#</th>
              <th>Motions</th>
              <th>Inference</th>
            </tr>
          </table> 
		</div>
	</body>
	
	  <!-- New "Try it on robot" section -->
  <hr>
  <p><b>Try it on the robot:</b></p>

  <label for="environment-options">Choose an Environemnt option:</label>
  <select name="environment-options" id="environment-options">
    <option value="environment:kitchen">Kitchen</option>
    <option value="environment:apartment">Apartment</option>
  </select>
  
  <label for="robot-options">for Robot:</label>
  <select name="robot-options" id="robot-options">
    <option value="robot:PR2">PR2</option>
  </select>
  
  

  <!-- Define the links corresponding to each option -->
  <button type="button" onclick="navigateToSelectedOption()"> Run </button>

  <!-- Add this script section to your HTML -->
<script>
  function navigateToSelectedOption() {
    var selectedEnvironmentOption = document.getElementById("environment-options").value;
    var selectedRobotOption = document.getElementById("robot-options").value;

    // Define links based on the combination of selected options
    var links = {
      'environment:kitchen:robot:PR2': 'https://binder.intel4coro.de/v2/gh/sunava/pycram/6083d5a6c005a862a56bf60deefc13a615f89121?urlpath=lab%2Ftree%2Fdemos%2Fpycram_cutting_demo%2Fcutting-example.ipynb',
      'environment:apartment:robot:PR2': 'https://binder.intel4coro.de/v2/gh/sunava/pycram/6083d5a6c005a862a56bf60deefc13a615f89121?urlpath=lab%2Ftree%2Fdemos%2Fpycram_cutting_demo%2Fcutting-example.ipynb',
    };

    // Construct the key based on the selected options
    var selectedKey = selectedEnvironmentOption + ':' + selectedRobotOption;

    // Redirect to the selected link
    var selectedLink = links[selectedKey];
    if (selectedLink) {
      window.location.href = selectedLink;
    } else {
      alert("No link defined for the selected combination.");
    }
  }
</script>
</html>
